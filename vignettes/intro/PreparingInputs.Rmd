---
title: "Preparing model inputs"
author: "Miquel De CÃ¡ceres"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## About this vignette

Vignette [*Understanding model inputs*](https://emf-creaf.github.io/medfate/articles/UnderstandingInputs.html). Preparing inputs for simulations with **medfate** is not straightforward, because it requires obtaining and reshaping data for vegetation, soil and weather. This vignette illustrates some common issues that arise in the process of preparing inputs, so that the user is aware of them when processing his/her own data.

We begin by loading packages **medfate**, **medfateutils** and **meteoland**:
```{r}
library(medfate)
library(medfateutils)
library(meteoland)
```

## Building a forest input Poblet oak forest

In this section we show how to build an object of class `forest`, for its use in package medfate, from a table containing forest inventory data.

### Poblet tree data set

Package `medfateutils` includes a small dataset of tree data, corresponding to a dense holm oak forest in Poblet (Catalonia, Spain). As a result of the abandonment of previous coppicing exploitation, there is a high density of stems per individual. 


We begin by loading the tree data from Poblet:

```{r}
data("poblet_trees")
```

and we inspect its content, for example using: 

```{r}
head(poblet_trees)
```

The data frame includes tree data corresponding to three forest inventories: 

```{r}
table(poblet_trees$Plot.Code)
```

`POBL_CTL` corresponds to an oak forest where no treatment was done (control), whereas `POBL_THI_BEF` and `POBL_THI_AFT` are two forest inventories conducted on the same forest plot, before and after a thinning intervention to reduce the number of stems.


### Mapping tree data from the control forest

We initialize an empty forest object using function `emptyforest()` from package **medfate**:
```{r}
forest_ctl <- emptyforest("POBL_CTL")
forest_ctl
```

Now we will fill in data for element `treeData` in the `forest` object. For that, we need to define a mapping from column names in `poblet_trees` to variables in `treeData`. The mapping can be defined using a **named string vector**, i.e. a vector where element names are variable names in `treeData` and vector elements are strings of the variable names in `poblet_trees`:
```{r}
mapping = c("Species.name" = "Species", "DBH" = "Diameter.cm")
```

We can now replace the empty `treeData` in `forest_ctl` using function `forest_mapTreeTable()` from **medfateutils**:
```{r}
forest_ctl$treeData <- forest_mapTreeTable(poblet_trees[poblet_trees$Plot.Code=="POBL_CTL",], 
                                           mapping = mapping, SpParams = SpParamsMED)
```

We can inspect the result using:
```{r}
summary(forest_ctl$treeData)
```

Some data are missing, but we will not worry about it now. One way to evaluate if the tree data is correctly specified is to display a summary of the `forest` object using the `summary` function defined in **medfate** for this object class:
```{r}
summary(forest_ctl, SpParamsMED)
```

The values of stand density and stand basal area are too low for such a dense forest, which indicates that something needs to be corrected. At this point, it is important to remember that `forest` objects need the density of trees to be specified as *stems per hectare*. We conducted our tree data mapping without indicating the area of the sampled plot. We are told that forest stand sampling was done using a circular plot whose radius was 15 m. We can calculate the sampled area using: 

```{r}
sampled_area = pi*15^2
```

and use this information to map the tree data again, where we specify parameter `plot.size`:

```{r}
forest_ctl$treeData <- forest_mapTreeTable(poblet_trees[poblet_trees$Plot.Code=="POBL_CTL",], 
                                           mapping = mapping, SpParams = SpParamsMED, 
                                           plot.size = sampled_area)
```

We run again the summary: 

```{r}
summary(forest_ctl, SpParamsMED)
```

which results in a much higher basal area and density, as should be expected for a dense oak forest resulting from an abandoned old coppice. 

Another issue that we see is the percentage of PAR and SWR that reaches the ground, which have missing values. This indicates that medfate cannot calculate the light extinction profile, in our case because tree heights are missing. Thus, we should somehow estimate tree heights, for example using an allometric relationship:

```{r}
poblet_trees$Height.cm = 100 * 1.806*poblet_trees$Diameter.cm^0.518
summary(poblet_trees$Height.cm)
```

So trees are between 5 and 10 m height. Once tree heights are defined, we can include them in our mapping:
```{r}
mapping = c("Species.name" = "Species", "DBH" = "Diameter.cm",
            "Height" = "Height.cm")
```

and rerun the tree data mapping:
```{r}
forest_ctl$treeData <- forest_mapTreeTable(poblet_trees[poblet_trees$Plot.Code=="POBL_CTL",], 
                                           mapping = mapping, SpParams = SpParamsMED, 
                                           plot.size = sampled_area)
```

Now the summary of the control forest stand looks like:
```{r}
summary(forest_ctl, SpParamsMED)
```

The fraction of PAR/SWR reaching the ground is low, as would be expected for a dense forest.

### Mapping tree data from the managed forest

Here we can repeat our mapping for the managed forest plot, which has two codes corresponding to before and after the thinning intervention. Let us first address the pre-thinning state:
```{r}
forest_thi_bef = emptyforest()
forest_thi_bef$treeData <- forest_mapTreeTable(poblet_trees[poblet_trees$Plot.Code=="POBL_THI_BEF",], 
                                mapping = mapping, SpParams = SpParamsMED, 
                                plot.size = sampled_area)

summary(forest_thi_bef$treeData)
```
Note that the `Species` variable contains two missing values. This will normally happen when some species cannot be identified. We can verify if this happens for other parts of the Poblet tree data:

```{r}
sum(!(poblet_trees$Species %in% SpParamsMED$Name))
```

If we display species counts we can identify which species is not being parsed:
```{r}
table(poblet_trees$Species)
```

In this case, the name used for the downy oak (*Quercus humilis*) is a synonym and needs to be replaced by^ its accepted name (*Quercus pubescens*), which we can do:
```{r}
poblet_trees$Species[poblet_trees$Species=="Quercus humilis"] = "Quercus pubescens"
```

Now we repeat our mapping:
```{r}
forest_thi_bef$treeData <- forest_mapTreeTable(poblet_trees[poblet_trees$Plot.Code=="POBL_THI_BEF",], 
                                mapping = mapping, SpParams = SpParamsMED, 
                                plot.size = sampled_area)

summary(forest_thi_bef, SpParamsMED)
```

Like the control plot, these statistics indicate a dense oak forest. We can repeat the same operations with the forest plot after the thinning intervention: 

```{r}
forest_thi_aft = emptyforest()
forest_thi_aft$treeData <- forest_mapTreeTable(poblet_trees[poblet_trees$Plot.Code=="POBL_THI_AFT",], 
                                mapping = mapping, SpParams = SpParamsMED, 
                                plot.size = sampled_area)

summary(forest_thi_aft, SpParamsMED)
```

Note the decrease in tree density and basal area, and the increase in light reaching the ground, despite the estimated leaf area index is still high.

### Reducing the number of woody cohorts

So far we have considered that each tree record should correspond to a woody cohort. This creates a fairly large amount of cohorts and can 
```{r}
nrow(forest_ctl$treeData)
nrow(forest_thi_bef$treeData)
nrow(forest_thi_aft$treeData)
```

```{r}
forest_ctl <- forest_mergeTrees(forest_ctl)
forest_thi_bef <- forest_mergeTrees(forest_thi_bef)
forest_thi_aft <- forest_mergeTrees(forest_thi_aft)
```

```{r}
nrow(forest_ctl$treeData)
nrow(forest_thi_bef$treeData)
nrow(forest_thi_aft$treeData)
```

## Retrieving SoilGrids data

Because soil properties vary strongly at fine spatial scales, ideally soil physical attributes should be measured on samples taken at the forest stand to be simulated. For those users lacking such data, soil properties modelled at larger scales are available via SoilGrids.org (see function `soilgridsParams()` in package [medfateutils](https://github.com/emf-creaf/medfateutils)).

```{r}
cc = cbind(1.0219, 41.3443)
coords_sp <- SpatialPoints(cc, CRS(SRS_string = "EPSG:4326"))
```

```{r}
poblet_soil <- soilgridsParams(coords_sp, widths = c(300, 700, 1000))
```


## Interpolating weather

```{r}
poblet_spt <- SpatialPointsTopography(coords_sp,
                                      elevation = 850, slope = 15.1, aspect = 15)
```


```{r}
data("exampleinterpolationdata")
```

```{r}
meteo <- interpolationpoints(exampleinterpolationdata, poblet_spt)
```

